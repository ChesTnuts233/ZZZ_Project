---
title: 算法笔记-栈实现队列
date: 2024-05-01 17:03:28
tags: 算法
---

# 栈实现队列

> 前言: 因为毕设和项目的一些事情，刷算法这件事确实是耽误了，现在得加把劲再捡起来

## 题目

> 请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（`push`、`pop`、`peek`、`empty`）：
>
> 实现 `MyQueue` 类：
>
> - `void push(int x)` 将元素 x 推到队列的末尾
> - `int pop()` 从队列的开头移除并返回元素
> - `int peek()` 返回队列开头的元素
> - `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`
>
> **说明：**
>
> - 你 **只能** 使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
> - 你所使用的语言也许不支持栈。你可以使用 list 或者 deque（双端队列）来模拟一个栈，只要是标准的栈操作即可。
>
>  
>
> **示例 1：**
>
> ```
> 输入：
> ["MyQueue", "push", "push", "peek", "pop", "empty"]
> [[], [1], [2], [], [], []]
> 输出：
> [null, null, null, 1, 1, false]
> 
> 解释：
> MyQueue myQueue = new MyQueue();
> myQueue.push(1); // queue is: [1]
> myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
> myQueue.peek(); // return 1
> myQueue.pop(); // return 1, queue is [2]
> myQueue.empty(); // return false
> ```
>
> 
>
>  
>
> **提示：**
>
> - `1 <= x <= 9`
> - 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
> - 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）
>
>  
>
> **进阶：**
>
> - 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。



我的想法非常简单 一个用来进的栈,一个用来出的栈 ，做队列操作的时候，重复对两个栈进出就行。

这里要注意的点就是 在倒转两个栈的时候 不要用for循环，而是使用while，为什么呢，因为使用for循环的时候，栈的大小是在变化的，根据栈的Count变化的i是不正确的。

```C#
public class MyQueue {

    public Stack<int> EnterStack = new();

    public Stack<int> ExitStack = new();

    public bool isInExit;


    public MyQueue() {

    }
    
    public void Push(int x) {
        EnterStack.Push(x);
    }
    
    public int Pop() {
        int result = 0;
        MoveItemToExit();
        result = ExitStack.Pop();
        MoveItemToEnter();
        return result;
    }
    
    
    public int Peek() {
        int result = 0;
        MoveItemToExit();
        result = ExitStack.Peek();
        MoveItemToEnter();
        return result;
    }
    
    public bool Empty() {
        return EnterStack.Count == 0 && ExitStack.Count == 0;
    }


    public void MoveItemToExit(){
        if (ExitStack.Count == 0) {
            while (EnterStack.Count > 0) {
                ExitStack.Push(EnterStack.Pop());
            }
        }
    }

    public void MoveItemToEnter(){
        if (EnterStack.Count == 0) {
            while (ExitStack.Count > 0) {
                EnterStack.Push(ExitStack.Pop());
            }
        }
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.Push(x);
 * int param_2 = obj.Pop();
 * int param_3 = obj.Peek();
 * bool param_4 = obj.Empty();
 */
```

![232.用栈实现队列版本2](https://code-thinking.cdn.bcebos.com/gifs/232.%E7%94%A8%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97%E7%89%88%E6%9C%AC2.gif)

下面放一下标准答案

```C#
public class MyQueue {
    Stack<int> inStack;
    Stack<int> outStack;

    public MyQueue() {
        inStack = new Stack<int>();// 负责进栈
        outStack = new Stack<int>();// 负责出栈
    }
    
    public void Push(int x) {
        inStack.Push(x);
    }
    
    public int Pop() {
        dumpstackIn();
        return outStack.Pop();
    }
    
    public int Peek() {
        dumpstackIn();
        return outStack.Peek();
    }
    
    public bool Empty() {
        return inStack.Count == 0 && outStack.Count == 0;
    }

    // 处理方法：
    // 如果outStack为空，那么将inStack中的元素全部放到outStack中
    private void dumpstackIn(){
        if (outStack.Count != 0) return; 
        while(inStack.Count != 0){
            outStack.Push(inStack.Pop());
        }
    }
}
```

